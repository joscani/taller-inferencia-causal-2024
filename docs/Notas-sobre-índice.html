<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.552">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>notas-sobre-índice</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="Notas-sobre-índice_files/libs/clipboard/clipboard.min.js"></script>
<script src="Notas-sobre-índice_files/libs/quarto-html/quarto.js"></script>
<script src="Notas-sobre-índice_files/libs/quarto-html/popper.min.js"></script>
<script src="Notas-sobre-índice_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Notas-sobre-índice_files/libs/quarto-html/anchor.min.js"></script>
<link href="Notas-sobre-índice_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Notas-sobre-índice_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Notas-sobre-índice_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Notas-sobre-índice_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Notas-sobre-índice_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="taller-causal-inference" class="level1">
<h1>Taller Causal Inference</h1>
<section id="preguntas-causales." class="level2">
<h2 class="anchored" data-anchor-id="preguntas-causales.">Preguntas causales.</h2>
<p>Creo que empezaré mi taller comentando algo que aunque parezca evidente no se suele decir. Hay dos tipos de cuestiones causales. 1- Efecto de las causas. El efecto de una intervención. 2- Causas de los efectos. Qué ha podido ser la causa de esto?</p>
</section>
<section id="the-whole-game" class="level2">
<h2 class="anchored" data-anchor-id="the-whole-game">0. The whole game</h2>
<p>Ejemplo completo aunque no se entienda de lo que se hace en inferencia causal. Explicar los puntos por los que ha de pasar la inferencia causal.</p>
<p>1 Ejemplo de los mosquitos ? Sacado del libro r-causal.org 2 Specify a causal question 3 Draw our assumptions using a causal diagram 4 Model our assumptions 5 Diagnose our models 6 Estimate the causal effect 7 Conduct sensitivity analysis on the effect estimate</p>
</section>
<section id="potential-outcomes" class="level2">
<h2 class="anchored" data-anchor-id="potential-outcomes">1. Potential outcomes</h2>
<p>Exponer el principal problema de la inferencia causal, que es la imposibilidad de tener contrafactuales a nivel individual</p>
<p>Ejemplo del libro ROS. hay imagen en carpeta fig.&nbsp;Texto en páginas 341 y siguientes. Útil el comentario de que la lógica bajo <em>pre-post</em> experimentos puede no ser suficiente, porque el valor previo de la presión arterial de un sujeto previo al experimento puede no ser una buena medida de su contrafactual.</p>
<section id="notas-del-libro-ros" class="level3">
<h3 class="anchored" data-anchor-id="notas-del-libro-ros">Notas del libro (ROS)</h3>
<p>At the design stage, we can use randomization to ensure that treatment and control groups are balanced in expectation, and we can use blocking to reduce the variation in any imbalance. At the analysis stage, we can adjust for pre-treatment variables to correct for differences between the two groups to reduce bias in our estimate of the sample average treatment effect</p>
<ul>
<li><p>External validity: Difficulty of extrapolating to new individuals and situations More generally, causal inference can be viewed as a special case of prediction in which the goal is to predict what would have happened under different treatment options. Causal interpretations of regression coefficients can only be justified by relying on much stronger assumptions than are needed for predictive inference.</p></li>
<li><p>However, in observational studies, treatment exposure is observed rather than manipulated (for example, comparisons of smokers to nonsmokers), and it is not reasonable to consider the observed data as reflecting a random allocation across treatment groups.Thus, in an observational study, there can be systematic differences between groups of units that receive different treatments with respect to key covariates, x, that can affect the outcome, y. Such covariates that are associated with the treatment and the potential outcomes are typically called confounders or confounding covariates because if we observe differences in average outcomes across these groups, we can’t separately attribute these differences to the treatment or the confounders—the effect of the treatment is thus “confounded” by these variables. -Matching refers to any of a variety of procedures that restructure the original sample in preparation for a statistical analysis. The goal of this restructuring in a causal inference setting is to create an analysis sample that looks like it was created from a randomized experiment. -Given this, how can we make decisions in a scenario where we are not convinced that all confounders have been included? One strategy to reduce risk is to avoid covariates that are strongly related to the treatment variable but not strongly related to the outcome. The classic example of a covariate that should not just be included as an additional predictor is an instrumental variable, as discussed in Section 21.1.</p></li>
<li><p>Said another way, it is only necessary to have common support with respect to confounders, not all covariates.</p></li>
</ul>
<p>We distinguish between two broad classes of causal queries: 1. Effects of causes. What might happen if we do z? What is the effect of some manipulation, for example, the effect of job training on poverty status, the effect of smoking on health, the effect of schooling on earnings, the effect of campaigns on election outcomes, and so forth? 2. Causes of effects. What causes y? Why do more attractive people earn more money? Why does per capita income vary so much by country? Why do many poor people vote for Republicans and rich people vote for Democrats? Why do some economies collapse while others thrive? When methodologists write about causal inference, they generally focus on the effects of causes. We are taught to answer questions of the type “What is the effect of z?”, rather than “What caused y?” As we have discussed in the preceding chapters, potential outcomes can be framed in terms of manipulations: if z were changed by one unit, how much would y be expected to change? But “What caused this?” questions are important too. They are a natural way to think, and in many ways, these causal questions motivate the research, including experiments and observational studies, that we use to estimate particular causal effects. How can we incorporate “What caused this?” questions into a statistical framework that is centered around “What is the effect of this?” causal inference? A potentially useful frame of this issue is as follows: “What is the effect?” causal inference is about estimation; “What caused this?” questions are more about model checking and hypothesis generation. Therefore we do not try to answer “What caused this?” questions; rather, our exploration of these questions motivates “What is the effect of?” questions that can be studied using statistical tools such as the ones we have discussed in these chapters: experiments and observational studies.</p>
</section>
</section>
<section id="supuestos-para-poder-hacer-estas-cosas-de-la-inferencia-causal" class="level2">
<h2 class="anchored" data-anchor-id="supuestos-para-poder-hacer-estas-cosas-de-la-inferencia-causal">2. Supuestos para poder hacer estas cosas de la inferencia causal</h2>
<ul>
<li><p>Los obvios: Causa ha de ser anterior al efecto Cómo solventar parcialmente el problema fundamental?</p></li>
<li><p>Exchangeability (El solapamiento)</p></li>
<li><p>Positivity</p></li>
<li><p>Consistency</p></li>
<li><p>Ignorability (no confounding)</p></li>
<li><p>Stable unit treatment value assumption (SUTVA)</p></li>
</ul>
<p>TODO (revisar) * ¿Qué pasa si no se cumplen? * Si no se cumple ignorability, tenemos confounding * Si no se cumple SUTVA, tenemos interferencia * Si no se cumple exchangeability, tenemos selection bias * Si no se cumple positivity, tenemos extrapolación * Si no se cumple consistency, tenemos measurement error</p>
<section id="asunciones-según-r-causal.org-me-gustan-más" class="level3">
<h3 class="anchored" data-anchor-id="asunciones-según-r-causal.org-me-gustan-más">Asunciones según r-causal.org (me gustan más )</h3>
<ol type="1">
<li><p>Consistencia: Qué realmente el análisis conteste a la pregunta causal 1.1 Buena definición del tratamiento. Que no haya múltiples versiones del mismo 1.2 No interferencia. Que la variable respuesta de un individuo no dependa de la asignación de tratmiento de otro. A la consistencia también se le conoce como SUTVA.</p></li>
<li><p>Intercambiabilidad: Se asume que dentro de los niveles de las covariables (variables de confusión) los individuos expuestos al tratamiento y no tratamiento tengan igual likelihood . A veces se dice que no hay variables de confusión no medidas.</p></li>
<li><p>Positividad: Que dentro de cada nivel y combinación de covariables, haya expuestos y no expuestos. O de otra manera, que cada individuo tenga alguna probabildidad de recibir o no el tratamiento. Básicamente positividad es que haya 0 &lt; p &lt; 1</p></li>
</ol>
<p>Se podría resumir como “peras con peras” y “manzanas con manzanas”. Suppose that there were in fact two containers of chocolate ice cream, one of which was spoiled</p>
<p>Violación de consistencia 1: El ejemplo que viene es bueno. 3 recipientes de helado. 2 tienen chocolate y 1 vainilla. Pero hay uno de chocolate en mal estado, que hace que la variable y (te gusta del 0 al 10) sea 0 para todo aquel que prueba ese chocolate. Pero no se les dice a la gente cual es cual. Entonces hay diferentes versiones de chocolate (normal y en mal estado) y si mezclas los outcomes para ver el efecto causal estás jodido. Violación de inconsistancia 2. interferencia. Si que un individuo reciba el tratamiento afecta a otro por ejemplo que en una ciudad se asignen precios bajos y altos de cabify ( y la gente se de cuenta) y lo diga a sus amigos, afecta a la probabilidad de que los amigos cojan cabify.. Solución =&gt; aleatorizar para dar tratamiento barato en una ciudad o barrio y caro en otro.</p>
<p>Violación de intercambialidad: In that example, participants were able to choose the ice cream that they wanted to eat, so people who were more likely to have a positive effect from eating chocolate chose that, and those more likely to have a positive effect from eating vanilla chose that.In that example, participants were able to choose the ice cream that they wanted to eat, so people who were more likely to have a positive effect from eating chocolate chose that, and those more likely to have a positive effect from eating vanilla chose that. Básicamente, significa que si a los más propensos a elegir chocolate les dejo elegir , elegirán chocolate y hay un sesgo con respecto a los que eligen vainilla..</p>
<pre><code>data &lt;- data.frame(
  id = 1:10,
  y_chocolate = c(4, 4, 6, 5, 6, 5, 6, 7, 5, 6),
  y_vanilla = c(1, 3, 4, 5, 5, 6, 8, 6, 3, 5)
)
data_observed &lt;- data |&gt;
  mutate(
    exposure = case_when(
      # people who like chocolate more chose that
      y_chocolate &gt; y_vanilla ~ "chocolate",
      # people who like vanilla more chose that
      y_vanilla &gt;= y_chocolate ~ "vanilla"
    ),
    observed_outcome = case_when(
      exposure == "chocolate" ~ y_chocolate,
      exposure == "vanilla" ~ y_vanilla
    )
  ) |&gt;
  select(id, exposure, observed_outcome)

data_observed |&gt;
  group_by(exposure) |&gt;
  summarise(avg_outcome = mean(observed_outcome))</code></pre>
<p>How could we correct this? If we had some people who preferred chocolate ice cream but ended up taking vanilla instead, we could adjust for the preference, and the effect conditioned on this would no longer have an exchangeability issue</p>
<p>Violación de positividad.En el ejemplo anterior, sólo si hay gente que elige vainilla en vez de chocolate aunque prefiera el chocolate, entonces se puede hacer algo. Tiene que ver con el solapamiento, etc. si entre la gente que prefiere el chocolate no hay nadie que haya elegido vainilla no se puede construir el contrafactuaal. Si hay al menos alguien que si entonces se puede intentar ajustando por esa variable.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>data <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">id =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>,</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">y_chocolate =</span> <span class="fu">c</span>(<span class="dv">4</span>, <span class="dv">4</span>, <span class="dv">6</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">5</span>, <span class="dv">6</span>),</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">y_vanilla =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">8</span>, <span class="dv">6</span>, <span class="dv">3</span>, <span class="dv">5</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">11</span>)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>data_observed <span class="ot">&lt;-</span> data <span class="sc">|&gt;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">prefer_chocolate =</span> y_chocolate <span class="sc">&gt;</span> y_vanilla,</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="at">exposure =</span> <span class="fu">case_when</span>(</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>      <span class="co"># people who like chocolate more chose that 80% of the time</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>      prefer_chocolate <span class="sc">~</span> <span class="fu">ifelse</span>(<span class="fu">rbinom</span>(<span class="fu">n</span>(), <span class="dv">1</span>, <span class="fl">0.8</span>), <span class="st">"chocolate"</span>, <span class="st">"vanilla"</span>),</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>      <span class="co"># people who like vanilla more chose that 80% of the time</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>      <span class="sc">!</span>prefer_chocolate <span class="sc">~</span> <span class="fu">ifelse</span>(<span class="fu">rbinom</span>(<span class="fu">n</span>(), <span class="dv">1</span>, <span class="fl">0.8</span>), <span class="st">"vanilla"</span>, <span class="st">"chocolate"</span>)</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    ),</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    <span class="at">observed_outcome =</span> <span class="fu">case_when</span>(</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>      exposure <span class="sc">==</span> <span class="st">"chocolate"</span> <span class="sc">~</span> y_chocolate,</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>      exposure <span class="sc">==</span> <span class="st">"vanilla"</span> <span class="sc">~</span> y_vanilla</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">|&gt;</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(id, prefer_chocolate, exposure, observed_outcome)</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a><span class="fu">lm</span>(</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>  observed_outcome <span class="sc">~</span> <span class="fu">I</span>(exposure <span class="sc">==</span> <span class="st">"chocolate"</span>) <span class="sc">+</span> prefer_chocolate,</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>  data_observed</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="rct-.-se-puede-hacer-siempre" class="level2">
<h2 class="anchored" data-anchor-id="rct-.-se-puede-hacer-siempre">3. RCT . ¿Se puede hacer siempre?</h2>
<ul>
<li>RCT es el gold standard, pero a veces no se puede</li>
</ul>
<p>En el ejemplo de la red de mosquito no se puede, porque no puedo elegir gente al azar y a unos obligarles a no tener red moquitera. Chiste negro no contar. Quizá en la Alemania nazi deberían haber aprovechado para hacer inferencia causal</p>
<p>Incluso si podemos hacer RCT, muchas de las técnicas mejoran la precisión de la estimación en ese caso</p>
</section>
<section id="pensemos-en-el-dag" class="level2">
<h2 class="anchored" data-anchor-id="pensemos-en-el-dag">4. Pensemos en el DAG</h2>
<p>Ciencia antes que estadística.</p>
<ul>
<li><p>Uso del DAG para hacer explícitas las asunciones. library(tidyverse) library(causalworkshop) net_data |&gt; ggplot(aes(malaria_risk, fill = net)) + geom_density(color = NA, alpha = .8)library(tidyverse) library(causalworkshop) net_data |&gt; ggplot(aes(malaria_risk, fill = net)) + geom_density(color = NA, alpha = .8)</p></li>
<li><p>Nomenclatura, puede que nueva para algunos.</p>
<ul>
<li>Forks</li>
<li>Mediators</li>
<li>Colliders</li>
</ul></li>
<li><p>Reglas de Pearl, (backdoor, frontdoor, etc), que nos pueden servir para identificar qué variables hemos de considerar, supuesto correcto el DAG.</p></li>
<li><p>¿nos podemos saltar algunas reglas de Pearl? Si, si ajustamos el sistema causal entero. Full-luxury</p></li>
</ul>
</section>
<section id="técnicas." class="level2">
<h2 class="anchored" data-anchor-id="técnicas.">5. Técnicas.</h2>
<p>Son sólo técnicas, lo importante es lo de antes</p>
<ul>
<li>Queremos acercarnos a lo que es un RCT, qué se puede hacer desde perspectiva clásica frecuentista.</li>
<li>Identificar variables con reglas de Pearl, uso de daggitty</li>
<li>Propensity Score Matching</li>
<li>Inverse Probability Weighting</li>
<li>Meta-learners</li>
<li>G-estimation ( esto nos sirve en frecuentista y en bayesiano)</li>
</ul>
</section>
<section id="oye-que-yo-soy-bayesiano" class="level2">
<h2 class="anchored" data-anchor-id="oye-que-yo-soy-bayesiano">6. Oye, que yo soy bayesiano</h2>
<p>Usando el DAG y técnicas bayesianas es todo más natural y sencillo. “La inferencia causal no es más que predecir el efecto de la intervención” (es lo que se hace con G-estimation)</p>
<p>Si el DAG es correcto, estímalo conjuntamente, nos podemos saltar reglas de Pearl Se puede “condicionar” por variables no observadas, o por colliders</p>
</section>
<section id="causal-forests-fuera-de-tiempo" class="level2">
<h2 class="anchored" data-anchor-id="causal-forests-fuera-de-tiempo">7. Causal Forests (fuera de tiempo)</h2>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>